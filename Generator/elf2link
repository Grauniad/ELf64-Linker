#!/bin/bash

# Luke Humphreys September 2012
#
# For simplicity the various functions load the results into a set of global
# variables. 
# Consequently it is really only sensible to run this script on one file at a
# time, a separate wrapepr script can process multple files if required

#Flags / options
verboseLINK=1
file=$1
#Global Variables to populate
declare -a segmentHeaders
declare -a segmentData

function getHeaderName {
   i=$1
   line=(${segmentHeaders[$i]}) 
   name=${line[0]}
   echo $name
}
function hasData {
   i=$1
   line=(${segmentHeaders[$i]}) 
   flags=${line[3]}
   if [[ $flags =~ "P" ]]; then
      echo 1
   else 
      echo 0
   fi
}

function getSegment {
   elffile=$1
   segment=$2
   nbytes=$3
   # let converts the hex to decimal and then doubles it - each byte is two hex
   # chars in LINK format
   let size="0x$nbytes*2"
   data=$(objdump --full-contents -j $segment $elffile | awk '/^ [0-9a-f ]+/ {printf "%s%s%s%s" , $2, $3, $4, $5};')
   # Yeah ok, but the regex isn't great. Clean out any additional data we picked
   # up along the way:
   data=${data:0:$size}
   echo $data

}

# Pull out the segment headers using objdump. 
function getSegHeaders {
   elffile=$1
   headerFile=$2
   objdump --headers $elffile | awk '/^ +[0-9]/ {printf "%s %s %s %s", $2 ,$3, $4, $7}; /^ +[A-Z]/ { printf "%s\n" , $0 }' > $headerFile
}

# Given a set of flags returned by objdump, convert these to single character
# flags used by LINK.
# Note: most of these flags are plain ignored by our tiny linker, but we should
# carry them through to make validating against ld linked files reasonable, and
# if we want to write a backwards converter in the future
function elfFlags2LINKFlags {
   elfflags=$1
   linkFlags=""
   declare -A flagMap
   flagMap[CONTENTS]="P"
   # in link R is readable, not readonly. There is a writeable flag, not a
   # readonly flag. see below
   flagMap[READONLY]="R"
   flagMap[ALLOC]="A"
   flagMap[LOAD]="L"
   flagMap[RELOC]="M"
   flagMap[DATA]="D"
   flagMap[CODE]="C"
   for flag in $elfflags; do
     # strip anyy ','s
     flag=${flag/,/}
     linkFlags="$linkFlags${flagMap[$flag]}"
   done
   if [[ ! -z $linkFlags ]]; then
       if [[ ! $linkFlags =~ ${flagMap[READONLY]} ]]; then
          #if not read only, add the writeable flag
          linkFlags="RW$linkFlags"
       fi
   fi
   echo "$linkFlags"
}

# Awk's does the messy bit and extracts the raw data from objdump, we then
# smash it into the LINK format with a little gratuitous violence
function processSegmentHeaders {
   fileName=$1
   headerFile="$fileName.headers"
   getSegHeaders $fileName $headerFile
   

   exec 5<>$headerFile
   readarray -u 5 lines
   nlines=${#lines[*]}
   for (( i=0; i<$nlines; i++)); do
      line=(${lines[$i]}) 
      name=${line[0]}
      size=${line[1]}
      address=${line[2]}
      #convert from 2**n format
      let alignment="${line[3]}" 
      flags=${line[@]:4}
      flags=$(elfFlags2LINKFlags "$flags")
      if [[ $flags =~ "P" ]]; then
         segmentData[$i]=$(getSegment $fileName $name $size)
      fi
      segmentHeaders[$i]="$name $address $size $flags $alignment"
   done
   
   rm "$headerFile"
}


function printLINKComments {
   if [[ $verboseLINK ]]; then
       echo "#$1"
   fi
}
function printHeader {
   nsegs="${#segmentHeaders[*]}"
   nsyms="0"
   nrelocs="0"
   printLINKComments "#file header:"
   printLINKComments "nsegs nsyms nrels"
   echo "$nsegs $nsyms $nrelocs"
}

function printSegmentHeaders {
    printLINKComments "Segment Headers: name (v)addr size flags"
    for (( i=0; i<${#segmentHeaders[*]}; i++)); do
        echo ${segmentHeaders[$i]}
    done
}
function printDataTable {
    printLINKComments "Segment data"
    for (( i=0; i<${#segmentHeaders[*]}; i++)); do
        if [[ "$(hasData $i)" != "0" ]]; then
            printLINKComments $(getHeaderName $i)
            echo ${segmentData[$i]}
        fi
    done
}
# We've got everything! lets write it out...
function printLINKFile {
    printLINKComments "File autogenerated by elf2link from $file"
    echo "LINK"
    printHeader
    printSegmentHeaders
    printLINKComments "Symbol / relocation tables have not been copied"
    printDataTable
}

# Main
pushd . >/dev/null || exit  
cp $file /tmp || exit
cd /tmp || exit
file=$(basename $file)
processSegmentHeaders $file
printLINKFile
rm $file
