#!/bin/bash

# Copyright Luke Humphreys September 2012
#
# For simplicity the various functions load the results into a set of global
# variables. 
# Consequently it is really only sensible to run this script on one file at a
# time, a separate wrapper script can process multple files if required
#



# Flags / options
verboseLINK=1
file=$1
arch=x86_64
# Constants
blankMarker="__blank__"
relocParser="$(dirname $0)/reloc.$arch.awk"

#Global Variables to populate
declare -a segmentHeaders
declare -a segmentData
declare -a symbolTable
declare -a relocTable
fileFlags=$(readelf -h $1  | grep Data: | awk '/2.s complement/ {printf "%s" ,2} /little endian/ {printf "%s", "L"} /big endian/ {printf "%s", "B"} END {printf "\n"}')

function main {
    pushd . >/dev/null || exit  
    cp $file /tmp || exit
    cp $relocParser /tmp || exit
    cd /tmp || exit
    file=$(basename $file)
    processSegmentHeaders $file
    processSymbolTable $file
    processRelocTable $file
    printLINKFile
    cd /tmp # just to make sure
    rm $file
    rm $(basename $relocParser)
}

# Awk's does the messy bit and extracts the raw data from objdump, we then
# smash it into the LINK format with a little gratuitous violence
function processSegmentHeaders {
   fileName=$1
   headerFile="$fileName.headers"
   getSegHeaders $fileName $headerFile
   

   exec 5<>$headerFile
   readarray -u 5 lines
   nlines=${#lines[*]}
   for (( i=0; i<$nlines; i++)); do
      line=(${lines[$i]}) 
      name=${line[0]}
      size=${line[1]}
      address=${line[2]}
      #convert from 2**n format
      let alignment="${line[3]}" 
      flags=${line[@]:4}
      flags=$(elfFlags2LINKFlags "$flags")
      if [[ $flags =~ "P" ]]; then
         segmentData[$i]=$(getSegment $fileName $name $size)
      fi
      segmentHeaders[$i]="$name $address $size $flags $alignment"
   done
   
   rm "$headerFile"
}

# This time there is pleasingly little violence required. readelf provides
# everything in basically the right format so we just nudge the fields into the
# correct order
function processSymbolTable {
   fileName=$1
   headerFile="$fileName.headers"
   getSymbolTable $fileName $headerFile

   exec 5<>$headerFile
   readarray -u 5 lines
   rm $headerFile
   nlines=${#lines[*]}
   for (( i=0; i<$nlines; i++)); do
      line=(${lines[$i]}) 
      name=$(extractSymbolName ${line[0]})
      value=${line[1]}
      segment=${line[2]}
      stype=${line[3]}
      scope=${line[4]}

      # Perform flag substitution
      stype=$(readelfSymbolType2LINK "$stype")
      scope=$(readelfSymbolType2LINK "$scope")

      # only intested in Segment index if its an int. 
      if  [[ "$segment" =~ [0-9] ]]; then
          sidx=$segment
      else
	  # in LINK valid indexes start at 1 so we may use 0 has an error flag
          sidx=0
      fi
      
      symbolTable[$i]="$name $value $sidx $stype $scope"
      
   done
}

# awk's does all the work here  - just read the result into the relocTable
function processRelocTable {
   fileName=$1
   headerFile="$fileName.headers"
   getRelocTable $fileName $headerFile

   exec 5<>$headerFile
   readarray -u 5 relocTable
   rm $headerFile
}

# We need some convention to handle blank symbol names
# arg1: name
function extractSymbolName {
      name=$1
      if [[ "$line" == "><" ]]; then
          name=$blankMarker
      else
          let namelen="${#name}-2"
          name=${name:1:$namelen}
      fi
      echo $name
}

function readelfSymbolType2LINK {
   elfflags=$1
   linkFlags=""
   declare -A flagMap
   flagMap[LOCAL]="L"
   flagMap[GLOBAL]="G"
   flagMap[NOTYPE]="U"
   flagMap[FILE]="F" 
   flagMap[SECTION]="S"
   flagMap[OBJECT]="O"
   flagMap[FUNC]="P"

   for flag in $elfflags; do
     linkFlags="$linkFlags${flagMap[$flag]}"
   done

   echo "$linkFlags"
}

# We've got everything! lets write it out...
function printLINKFile {
    printLINKComments "File autogenerated by elf2link from $file"
    echo "LINK"
    printHeader
    printSegmentHeaders
    printSymbolTable
    printRelocTable
    printDataTable
}



# Extract the actual data segment
function getSegment {
   elffile=$1
   segment=$2
   nbytes=$3
   # let converts the hex to decimal and then doubles it - each byte is two hex
   # chars in LINK format
   let size="0x$nbytes*2"
   data=$(objdump --full-contents -j $segment $elffile | awk '/^ [0-9a-f ]+/ {printf "%s%s%s%s" , $2, $3, $4, $5};')
   # Yeah ok, but the regex isn't great. Clean out any additional data we picked
   # up along the way:
   data=${data:0:$size}
   echo $data

}


# Given a set of segment flags returned by objdump, convert these to single
# character
# flags used by LINK.
# Note: most of these flags are plain ignored by our tiny linker, but we should
# carry them through to make validating against ld linked files reasonable, and
# if we want to write a backwards converter in the future
function elfFlags2LINKFlags {
   elfflags=$1
   linkFlags=""
   declare -A flagMap
   flagMap[CONTENTS]="P"
   # in link R is readable, not readonly. There is a writeable flag, not a
   # readonly flag. see below
   flagMap[READONLY]="R"
   flagMap[ALLOC]="A"
   flagMap[LOAD]="L"
   flagMap[RELOC]="M"
   flagMap[DATA]="D"
   flagMap[CODE]="C"
   for flag in $elfflags; do
     # strip anyy ','s
     flag=${flag/,/}
     linkFlags="$linkFlags${flagMap[$flag]}"
   done
   if [[ ! -z $linkFlags ]]; then
       # A bit of hackery to convert from A  READONLY convention from objdump
       # into a write flag convention in LINK
       if [[ ! $linkFlags =~ ${flagMap[READONLY]} ]]; then
          #if not read only, add the writeable flag
          linkFlags="RW$linkFlags"
       fi
   fi
   echo "$linkFlags"
}

# Pull out the segment headers using objdump. 
function getSegHeaders {
   elffile=$1
   headerFile=$2
   objdump --headers $elffile | awk '/^ +[0-9]/ {printf "%s %s %s %s", $2 ,$3, $4, $7}; /^ +[A-Z]/ { printf "%s\n" , $0 }' > $headerFile
}




# This time we use readelf (objdumps format is less helpful, not providing a
# segment index for example)
# We inclose the name with "><" as hack to safely handle the symbols with no
# name
function getSymbolTable {
    elffile=$1
    headerFile=$2
    readelf -s $elffile  | awk '/^ +[0-9]/ {printf ">%s< %s %s %s %s\n" , $8 , $2,  $7, $4, $5}' > $headerFile
    
}


# Here we have no choice but to dig into the arch. specific ABI. call an
# external awk file and we can easily switch it for different archs (if we had
# the right script). 
function getRelocTable {
    elffile=$1
    headerFile=$2
    readelf -ra $elffile  | awk -f $relocParser > $headerFile || exit
}

function printHeader {
   nsegs="${#segmentHeaders[*]}"
   nsyms="${#symbolTable[*]}"
   nrelocs="${#relocTable[*]}"
   printLINKComments "#file header:"
   printLINKComments "nsegs nsyms nrels flags"
   echo "$nsegs $nsyms $nrelocs $fileFlags"
}

function printSegmentHeaders {
    printLINKComments "Segment Headers: name (v)addr size flags"
    for (( i=0; i<${#segmentHeaders[*]}; i++)); do
        echo ${segmentHeaders[$i]}
    done
}

function printDataTable {
    printLINKComments "Segment data"
    for (( i=0; i<${#segmentHeaders[*]}; i++)); do
        if [[ "$(hasData $i)" != "0" ]]; then
            printLINKComments $(getHeaderName $i)
            echo ${segmentData[$i]}
        fi
    done
}
function printSymbolTable {
    printLINKComments "Symbol Table"
    printLINKComments "name value segmentIndex type scope"
    for (( i=0; i<${#symbolTable[*]}; i++)); do
        echo ${symbolTable[$i]}
    done
}
function printRelocTable {
    printLINKComments "Reloc Table"
    printLINKComments "name value segmentIndex type scope"
    for (( i=0; i<${#relocTable[*]}; i++)); do
        echo ${relocTable[$i]}
    done
}

function printLINKComments {
   if [[ $verboseLINK ]]; then
       echo "#$1"
   fi
}

function getHeaderName {
   i=$1
   line=(${segmentHeaders[$i]}) 
   name=${line[0]}
   echo $name
}

function hasData {
   i=$1
   line=(${segmentHeaders[$i]}) 
   flags=${line[3]}
   if [[ $flags =~ "P" ]]; then
      echo 1
   else 
      echo 0
   fi
}

main
